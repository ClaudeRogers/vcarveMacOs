import Foundation
import VCarveCore
import VCarveToolpath

/// Generates G-code output from computed toolpaths.
public struct GCodeGenerator {

    /// Configuration for G-code output format.
    public struct OutputConfig: Codable, Sendable {
        public var postProcessor: PostProcessor
        public var unit: MeasurementUnit
        public var lineNumbers: Bool
        public var lineNumberIncrement: Int
        public var decimalPlaces: Int
        public var useArcCommands: Bool  // G2/G3 vs linearized arcs
        public var includeComments: Bool
        public var includeToolChanges: Bool
        public var fileExtension: String

        public init(
            postProcessor: PostProcessor = .grbl,
            unit: MeasurementUnit = .millimeters,
            lineNumbers: Bool = false,
            lineNumberIncrement: Int = 10,
            decimalPlaces: Int = 3,
            useArcCommands: Bool = true,
            includeComments: Bool = true,
            includeToolChanges: Bool = true,
            fileExtension: String = "gcode"
        ) {
            self.postProcessor = postProcessor
            self.unit = unit
            self.lineNumbers = lineNumbers
            self.lineNumberIncrement = lineNumberIncrement
            self.decimalPlaces = decimalPlaces
            self.useArcCommands = useArcCommands
            self.includeComments = includeComments
            self.includeToolChanges = includeToolChanges
            self.fileExtension = fileExtension
        }
    }

    private let config: OutputConfig

    public init(config: OutputConfig = OutputConfig()) {
        self.config = config
    }

    /// Generate G-code string from a computed toolpath.
    public func generate(
        toolpath: ComputedToolpath,
        tool: Tool,
        material: MaterialSetup,
        jobName: String = "VCarve Job"
    ) -> String {
        var lines: [String] = []
        var lineNumber = config.lineNumberIncrement

        // Header
        lines.append(contentsOf: generateHeader(jobName: jobName, tool: tool, material: material))

        // Setup commands
        lines.append(contentsOf: config.postProcessor.headerCommands(unit: config.unit))

        // Spindle on
        lines.append(comment("Start spindle"))
        lines.append("M3 S\(Int(tool.spindleSpeed))")

        // Process moves
        var lastMotion: MotionType?

        for move in toolpath.moves {
            let line = generateMoveLine(move: move, lastMotion: &lastMotion)
            if config.lineNumbers {
                lines.append("N\(lineNumber) \(line)")
                lineNumber += config.lineNumberIncrement
            } else {
                lines.append(line)
            }
        }

        // Footer
        lines.append(contentsOf: generateFooter(material: material))

        return lines.joined(separator: "\n") + "\n"
    }

    /// Generate G-code for multiple toolpaths (combined output).
    public func generateCombined(
        toolpaths: [(ComputedToolpath, Tool)],
        material: MaterialSetup,
        jobName: String = "VCarve Job"
    ) -> String {
        var lines: [String] = []

        // Header
        if let firstTool = toolpaths.first?.1 {
            lines.append(contentsOf: generateHeader(jobName: jobName, tool: firstTool, material: material))
        }

        lines.append(contentsOf: config.postProcessor.headerCommands(unit: config.unit))

        var currentToolID: UUID?

        for (toolpath, tool) in toolpaths {
            // Tool change if needed
            if tool.id != currentToolID {
                if currentToolID != nil {
                    lines.append("M5") // Spindle off
                    lines.append(comment("Tool change: \(tool.name)"))
                    if config.includeToolChanges {
                        lines.append("M6 T\(tool.numberOfFlutes)") // Simplified tool number
                    }
                }
                lines.append("M3 S\(Int(tool.spindleSpeed))")
                currentToolID = tool.id
            }

            lines.append(comment("Toolpath: \(toolpath.configID)"))

            var lastMotion: MotionType?
            for move in toolpath.moves {
                lines.append(generateMoveLine(move: move, lastMotion: &lastMotion))
            }
        }

        lines.append(contentsOf: generateFooter(material: material))
        return lines.joined(separator: "\n") + "\n"
    }

    // MARK: - Private helpers

    private func generateHeader(jobName: String, tool: Tool, material: MaterialSetup) -> [String] {
        var lines: [String] = []

        if config.includeComments {
            lines.append(comment("Generated by VCarve for macOS"))
            lines.append(comment("Job: \(jobName)"))
            lines.append(comment("Tool: \(tool.name) (\(formatNum(tool.diameter))\(material.unit.abbreviation))"))
            lines.append(comment("Material: \(formatNum(material.width)) x \(formatNum(material.height)) x \(formatNum(material.thickness)) \(material.unit.abbreviation)"))
            lines.append(comment("Date: \(ISO8601DateFormatter().string(from: Date()))"))
        }

        return lines
    }

    private func generateFooter(material: MaterialSetup) -> [String] {
        var lines: [String] = []

        lines.append("M5") // Spindle off
        lines.append(comment("Return to home"))
        lines.append("G0 Z\(formatNum(material.safeZHeight))")

        let home = material.homePosition
        lines.append("G0 X\(formatNum(home.x)) Y\(formatNum(home.y))")

        lines.append(contentsOf: config.postProcessor.footerCommands())

        return lines
    }

    private func generateMoveLine(move: ToolpathMove, lastMotion: inout MotionType?) -> String {
        var parts: [String] = []

        // G-code command (with modal optimization)
        let gCode: String
        switch move.type {
        case .rapid:
            gCode = "G0"
        case .linear:
            gCode = "G1"
        case .cwArc:
            gCode = "G2"
        case .ccwArc:
            gCode = "G3"
        }

        // Only output G-code if it changed (modal)
        if move.type != lastMotion || lastMotion == nil {
            parts.append(gCode)
        }
        lastMotion = move.type

        // Coordinates
        parts.append("X\(formatNum(move.position.x))")
        parts.append("Y\(formatNum(move.position.y))")
        parts.append("Z\(formatNum(move.position.z))")

        // Feed rate (for cutting moves)
        if let feedRate = move.feedRate {
            parts.append("F\(formatNum(feedRate))")
        }

        // Arc center (I, J for G2/G3)
        if let center = move.arcCenter {
            parts.append("I\(formatNum(center.x))")
            parts.append("J\(formatNum(center.y))")
        }

        return parts.joined(separator: " ")
    }

    private func comment(_ text: String) -> String {
        config.postProcessor.commentStyle.format(text)
    }

    private func formatNum(_ value: Double) -> String {
        String(format: "%.\(config.decimalPlaces)f", value)
    }
}
